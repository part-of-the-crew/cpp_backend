#include "ppm_image.h"

#include <iostream>
#include <string_view>

using namespace std;

int main(int argc, const char** argv) {
    if (argc != 3) {
        cerr << "Usage: "sv << argv[0] << " <input image> <output image>"sv << endl;
        return 1;
    }

    const auto image = img_lib::LoadPPM(argv[1]);
    if (!image) {
        cerr << "Error loading image"sv << endl;
        return 2;
    }

    if (!img_lib::SavePPM(argv[2], image)) {
        cerr << "Error saving image"sv << endl;
        return 3;
    }

    cout << "Image saved successfully!"sv << endl;
}
/*
Задание
В этой теме будет много работы с изображениями. Начнём с самого простого формата — PPM. Он не использует сжатие и записывает заголовок файлов в текстовом виде. В заготовке кода есть функция чтения изображений этого формата. Разработайте функцию записи.
Изображение будем хранить в уже реализованном в заготовке классе img_lib::Image. Изображение состоит из строк, а строки — из пикселей. Каждый пиксель определяется цветом, задаваемым четырьмя компонентами:
R — красный,
G — зелёный,
B — синий,
A — прозрачность.
Каждая компонента представлена числом типа std::byte, принимающим целые значения от 0 до 255. Ноль соответствует минимальной яркости соответствующей компоненты или полной прозрачности, 255 — максимальной яркости или полной непрозрачности. Для задания цвета используем класс img_lib::Color. Все пиксели изображения хранятся в одном векторе. Также в классе хранятся:
width — ширина изображения в пикселях,
height — высота изображения в пикселях,
step — отступ, то есть количество пикселей в одной строке.
Отступ может быть равен ширине, а может превышать её. Пиксели в каждой строке хранятся последовательно. Если отступ больше ширины, лишние пиксели в каждой строке не имеют значения, это просто padding.
Считается, что строки располагаются сверху вниз, а пиксели в строках — слева направо. Первый элемент вектора соответствует левому верхнему углу изображения.
С форматом PPM вы можете познакомиться, изучив код чтения в функции LoadPPM в заготовке кода. Реализовать нужно только запись — функцию SavePPM.
Формат входных данных
Программа должна поддерживать только один из шести возможных форматов PPM — P6. Этот код указывается в начале файла. После него идут ширина и высота изображения, записанные обычными числами в текстовом виде. Заканчивается заголовок максимальным значением цвета. Это число, которое в рассматриваемых примерах будет всегда равно 255. Другие значения можно не учитывать. Элементы заголовка разделяются пробельными символами — пробелами или переносами строки. После заголовка записан символ перевода строки \n и начинаются данные изображения. Пиксели кодируются подряд, каждый тремя байтами — значениями R, G и B. Прозрачность игнорируется.
Формат выходных данных
Формат выходных данных тот же. Программа читает и пишет PPM.
Ограничения
Используйте временный буфер для сокращения количества операций ввода-вывода. Писать каждый пиксель отдельно — недопустимо. Писать по строке или по 1024 пикселей — годится.
Функция должна возвратить true, если все операции записи завершились успехом.
Заголовок должен иметь в точности такой вид:
На первой строке два символа: P6.
На второй строке ширина и высота через пробел.
На третьей строке число 255.
Со следующей строки начинаются бинарные данные изображения.
Строки разделяются одним символом \n.
Открывайте файл только в бинарном формате.
Изображения, на которых будет тестироваться программа, имеют произведение ширины на высоту менее 2³¹.
Пример
В заготовке кода помимо img_lib есть функция main, которая обрабатывает два параметра командной строки — имя входного и выходного файла. Она загружает изображение из первого и в том же виде сохраняет во второй.
В приложенном архиве — файл PPM. Он не должен меняться после запуска программы.
image
kissy++.zip
Что отправлять на проверку
Реализуйте в заготовке функцию SavePPM из файла ppm_image.cpp. Не меняйте другие функции.
Как будет тестироваться ваш код
Мы проверим, что:
функция корректно сохраняет данное изображение,
заголовок имеет описанный формат,
не выполняется слишком много операций ввода-вывода,
функция возвращает false, если не удалось записать изображение. В противном случае возвращает true.


Как и в процедуре чтения, вам понадобятся два вложенных цикла.
Поток ostream не умеет работать с byte, он поддерживает только char. Создайте для хранения строки перед записью временный вектор элементов char размером в три ширины изображения.
Конвертируйте из byte в char через static_cast<char>.
Не забудьте флаг ios::binary при открытии двоичного файла.
*/